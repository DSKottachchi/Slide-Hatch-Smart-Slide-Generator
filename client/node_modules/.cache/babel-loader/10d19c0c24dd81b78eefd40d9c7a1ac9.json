{"ast":null,"code":"/*\n * JavaScript Load Image Meta\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Image meta data handling implementation\n * based on the help and contribution of\n * Achim StÃ¶hr.\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, DataView, Uint8Array */\n;\n\n(function (factory) {\n  'use strict';\n\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image'], factory);\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'));\n  } else {\n    // Browser globals:\n    factory(window.loadImage);\n  }\n})(function (loadImage) {\n  'use strict';\n\n  var hasblobSlice = typeof Blob !== 'undefined' && (Blob.prototype.slice || Blob.prototype.webkitSlice || Blob.prototype.mozSlice);\n\n  loadImage.blobSlice = hasblobSlice && function () {\n    var slice = this.slice || this.webkitSlice || this.mozSlice;\n    return slice.apply(this, arguments);\n  };\n\n  loadImage.metaDataParsers = {\n    jpeg: {\n      0xffe1: [],\n      // APP1 marker\n      0xffed: [] // APP13 marker\n\n    }\n  }; // Parses image meta data and calls the callback with an object argument\n  // with the following properties:\n  // * imageHead: The complete image head as ArrayBuffer (Uint8Array for IE10)\n  // The options argument accepts an object and supports the following\n  // properties:\n  // * maxMetaDataSize: Defines the maximum number of bytes to parse.\n  // * disableImageHead: Disables creating the imageHead property.\n\n  loadImage.parseMetaData = function (file, callback, options, data) {\n    // eslint-disable-next-line no-param-reassign\n    options = options || {}; // eslint-disable-next-line no-param-reassign\n\n    data = data || {};\n    var that = this; // 256 KiB should contain all EXIF/ICC/IPTC segments:\n\n    var maxMetaDataSize = options.maxMetaDataSize || 262144;\n    var noMetaData = !(typeof DataView !== 'undefined' && file && file.size >= 12 && file.type === 'image/jpeg' && loadImage.blobSlice);\n\n    if (noMetaData || !loadImage.readFile(loadImage.blobSlice.call(file, 0, maxMetaDataSize), function (e) {\n      if (e.target.error) {\n        // FileReader error\n        // eslint-disable-next-line no-console\n        console.log(e.target.error);\n        callback(data);\n        return;\n      } // Note on endianness:\n      // Since the marker and length bytes in JPEG files are always\n      // stored in big endian order, we can leave the endian parameter\n      // of the DataView methods undefined, defaulting to big endian.\n\n\n      var buffer = e.target.result;\n      var dataView = new DataView(buffer);\n      var offset = 2;\n      var maxOffset = dataView.byteLength - 4;\n      var headLength = offset;\n      var markerBytes;\n      var markerLength;\n      var parsers;\n      var i; // Check for the JPEG marker (0xffd8):\n\n      if (dataView.getUint16(0) === 0xffd8) {\n        while (offset < maxOffset) {\n          markerBytes = dataView.getUint16(offset); // Search for APPn (0xffeN) and COM (0xfffe) markers,\n          // which contain application-specific meta-data like\n          // Exif, ICC and IPTC data and text comments:\n\n          if (markerBytes >= 0xffe0 && markerBytes <= 0xffef || markerBytes === 0xfffe) {\n            // The marker bytes (2) are always followed by\n            // the length bytes (2), indicating the length of the\n            // marker segment, which includes the length bytes,\n            // but not the marker bytes, so we add 2:\n            markerLength = dataView.getUint16(offset + 2) + 2;\n\n            if (offset + markerLength > dataView.byteLength) {\n              // eslint-disable-next-line no-console\n              console.log('Invalid meta data: Invalid segment size.');\n              break;\n            }\n\n            parsers = loadImage.metaDataParsers.jpeg[markerBytes];\n\n            if (parsers && !options.disableMetaDataParsers) {\n              for (i = 0; i < parsers.length; i += 1) {\n                parsers[i].call(that, dataView, offset, markerLength, data, options);\n              }\n            }\n\n            offset += markerLength;\n            headLength = offset;\n          } else {\n            // Not an APPn or COM marker, probably safe to\n            // assume that this is the end of the meta data\n            break;\n          }\n        } // Meta length must be longer than JPEG marker (2)\n        // plus APPn marker (2), followed by length bytes (2):\n\n\n        if (!options.disableImageHead && headLength > 6) {\n          if (buffer.slice) {\n            data.imageHead = buffer.slice(0, headLength);\n          } else {\n            // Workaround for IE10, which does not yet\n            // support ArrayBuffer.slice:\n            data.imageHead = new Uint8Array(buffer).subarray(0, headLength);\n          }\n        }\n      } else {\n        // eslint-disable-next-line no-console\n        console.log('Invalid JPEG file: Missing JPEG marker.');\n      }\n\n      callback(data);\n    }, 'readAsArrayBuffer')) {\n      callback(data);\n    }\n  }; // Replaces the image head of a JPEG blob with the given one.\n  // Calls the callback with the new Blob:\n\n\n  loadImage.replaceHead = function (blob, head, callback) {\n    loadImage.parseMetaData(blob, function (data) {\n      callback(new Blob([head, loadImage.blobSlice.call(blob, data.imageHead.byteLength)], {\n        type: 'image/jpeg'\n      }));\n    }, {\n      maxMetaDataSize: 256,\n      disableMetaDataParsers: true\n    });\n  };\n\n  var originalTransform = loadImage.transform;\n\n  loadImage.transform = function (img, options, callback, file, data) {\n    if (loadImage.hasMetaOption(options)) {\n      loadImage.parseMetaData(file, function (data) {\n        originalTransform.call(loadImage, img, options, callback, file, data);\n      }, options, data);\n    } else {\n      originalTransform.apply(loadImage, arguments);\n    }\n  };\n});","map":{"version":3,"sources":["/Users/dilmikottachchi/Documents/Final Year Research Project/slide-generator-web/client/node_modules/blueimp-load-image/js/load-image-meta.js"],"names":["factory","define","amd","module","exports","require","window","loadImage","hasblobSlice","Blob","prototype","slice","webkitSlice","mozSlice","blobSlice","apply","arguments","metaDataParsers","jpeg","parseMetaData","file","callback","options","data","that","maxMetaDataSize","noMetaData","DataView","size","type","readFile","call","e","target","error","console","log","buffer","result","dataView","offset","maxOffset","byteLength","headLength","markerBytes","markerLength","parsers","i","getUint16","disableMetaDataParsers","length","disableImageHead","imageHead","Uint8Array","subarray","replaceHead","blob","head","originalTransform","transform","img","hasMetaOption"],"mappings":"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","sourcesContent":["/*\n * JavaScript Load Image Meta\n * https://github.com/blueimp/JavaScript-Load-Image\n *\n * Copyright 2013, Sebastian Tschan\n * https://blueimp.net\n *\n * Image meta data handling implementation\n * based on the help and contribution of\n * Achim StÃ¶hr.\n *\n * Licensed under the MIT license:\n * https://opensource.org/licenses/MIT\n */\n\n/* global define, module, require, DataView, Uint8Array */\n\n;(function (factory) {\n  'use strict'\n  if (typeof define === 'function' && define.amd) {\n    // Register as an anonymous AMD module:\n    define(['./load-image'], factory)\n  } else if (typeof module === 'object' && module.exports) {\n    factory(require('./load-image'))\n  } else {\n    // Browser globals:\n    factory(window.loadImage)\n  }\n})(function (loadImage) {\n  'use strict'\n\n  var hasblobSlice =\n    typeof Blob !== 'undefined' &&\n    (Blob.prototype.slice ||\n      Blob.prototype.webkitSlice ||\n      Blob.prototype.mozSlice)\n\n  loadImage.blobSlice =\n    hasblobSlice &&\n    function () {\n      var slice = this.slice || this.webkitSlice || this.mozSlice\n      return slice.apply(this, arguments)\n    }\n\n  loadImage.metaDataParsers = {\n    jpeg: {\n      0xffe1: [], // APP1 marker\n      0xffed: [] // APP13 marker\n    }\n  }\n\n  // Parses image meta data and calls the callback with an object argument\n  // with the following properties:\n  // * imageHead: The complete image head as ArrayBuffer (Uint8Array for IE10)\n  // The options argument accepts an object and supports the following\n  // properties:\n  // * maxMetaDataSize: Defines the maximum number of bytes to parse.\n  // * disableImageHead: Disables creating the imageHead property.\n  loadImage.parseMetaData = function (file, callback, options, data) {\n    // eslint-disable-next-line no-param-reassign\n    options = options || {}\n    // eslint-disable-next-line no-param-reassign\n    data = data || {}\n    var that = this\n    // 256 KiB should contain all EXIF/ICC/IPTC segments:\n    var maxMetaDataSize = options.maxMetaDataSize || 262144\n    var noMetaData = !(\n      typeof DataView !== 'undefined' &&\n      file &&\n      file.size >= 12 &&\n      file.type === 'image/jpeg' &&\n      loadImage.blobSlice\n    )\n    if (\n      noMetaData ||\n      !loadImage.readFile(\n        loadImage.blobSlice.call(file, 0, maxMetaDataSize),\n        function (e) {\n          if (e.target.error) {\n            // FileReader error\n            // eslint-disable-next-line no-console\n            console.log(e.target.error)\n            callback(data)\n            return\n          }\n          // Note on endianness:\n          // Since the marker and length bytes in JPEG files are always\n          // stored in big endian order, we can leave the endian parameter\n          // of the DataView methods undefined, defaulting to big endian.\n          var buffer = e.target.result\n          var dataView = new DataView(buffer)\n          var offset = 2\n          var maxOffset = dataView.byteLength - 4\n          var headLength = offset\n          var markerBytes\n          var markerLength\n          var parsers\n          var i\n          // Check for the JPEG marker (0xffd8):\n          if (dataView.getUint16(0) === 0xffd8) {\n            while (offset < maxOffset) {\n              markerBytes = dataView.getUint16(offset)\n              // Search for APPn (0xffeN) and COM (0xfffe) markers,\n              // which contain application-specific meta-data like\n              // Exif, ICC and IPTC data and text comments:\n              if (\n                (markerBytes >= 0xffe0 && markerBytes <= 0xffef) ||\n                markerBytes === 0xfffe\n              ) {\n                // The marker bytes (2) are always followed by\n                // the length bytes (2), indicating the length of the\n                // marker segment, which includes the length bytes,\n                // but not the marker bytes, so we add 2:\n                markerLength = dataView.getUint16(offset + 2) + 2\n                if (offset + markerLength > dataView.byteLength) {\n                  // eslint-disable-next-line no-console\n                  console.log('Invalid meta data: Invalid segment size.')\n                  break\n                }\n                parsers = loadImage.metaDataParsers.jpeg[markerBytes]\n                if (parsers && !options.disableMetaDataParsers) {\n                  for (i = 0; i < parsers.length; i += 1) {\n                    parsers[i].call(\n                      that,\n                      dataView,\n                      offset,\n                      markerLength,\n                      data,\n                      options\n                    )\n                  }\n                }\n                offset += markerLength\n                headLength = offset\n              } else {\n                // Not an APPn or COM marker, probably safe to\n                // assume that this is the end of the meta data\n                break\n              }\n            }\n            // Meta length must be longer than JPEG marker (2)\n            // plus APPn marker (2), followed by length bytes (2):\n            if (!options.disableImageHead && headLength > 6) {\n              if (buffer.slice) {\n                data.imageHead = buffer.slice(0, headLength)\n              } else {\n                // Workaround for IE10, which does not yet\n                // support ArrayBuffer.slice:\n                data.imageHead = new Uint8Array(buffer).subarray(0, headLength)\n              }\n            }\n          } else {\n            // eslint-disable-next-line no-console\n            console.log('Invalid JPEG file: Missing JPEG marker.')\n          }\n          callback(data)\n        },\n        'readAsArrayBuffer'\n      )\n    ) {\n      callback(data)\n    }\n  }\n\n  // Replaces the image head of a JPEG blob with the given one.\n  // Calls the callback with the new Blob:\n  loadImage.replaceHead = function (blob, head, callback) {\n    loadImage.parseMetaData(\n      blob,\n      function (data) {\n        callback(\n          new Blob(\n            [head, loadImage.blobSlice.call(blob, data.imageHead.byteLength)],\n            { type: 'image/jpeg' }\n          )\n        )\n      },\n      { maxMetaDataSize: 256, disableMetaDataParsers: true }\n    )\n  }\n\n  var originalTransform = loadImage.transform\n  loadImage.transform = function (img, options, callback, file, data) {\n    if (loadImage.hasMetaOption(options)) {\n      loadImage.parseMetaData(\n        file,\n        function (data) {\n          originalTransform.call(loadImage, img, options, callback, file, data)\n        },\n        options,\n        data\n      )\n    } else {\n      originalTransform.apply(loadImage, arguments)\n    }\n  }\n})\n"]},"metadata":{},"sourceType":"script"}